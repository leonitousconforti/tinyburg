import { FileSystem, Path } from "@effect/platform";
import { NodeContext, NodeRuntime } from "@effect/platform-node";
import { RpcClient } from "@effect/rpc";
import { FridaDevice } from "@efffrida/frida-tools";
import { Array, Effect, Layer, Logger, LogLevel, Order, pipe, Record } from "effect";

import { AgentLive } from "@tinyburg/insight/node/index";
import { Rpcs } from "@tinyburg/insight/shared/Rpcs";

const sortIndexable = <T extends Readonly<{ index: string }>>(
    input: Readonly<Record<string, T>>
): Array<Omit<T, "index"> & { readonly name: string }> =>
    pipe(
        input,
        Record.toEntries,
        Array.map(([name, object]) => ({ name, ...object })),
        Array.sortWith(({ index }) => Number.parseInt(index), Order.number),
        Array.map(({ index: _index, ...rest }) => ({ ...rest }))
    );

const replaceEnumTypeFields = (
    stringified: string,
    fieldname: string,
    enums: Readonly<Record<string, string>>,
    typeName: string
): string => {
    return stringified.replace(
        new RegExp(`"${fieldname}":\\s*"(${Object.keys(enums).join("|")})"`, "g"),
        (_match, p1) => `"${fieldname}": ${typeName}.${p1}`
    );
};

const program = Effect.gen(function* () {
    const path = yield* Path.Path;
    const fileSystem = yield* FileSystem.FileSystem;
    const internalDir = yield* path.fromFileUrl(new URL("../src/internal", import.meta.url));

    const client = yield* RpcClient.make(Rpcs);
    yield* client.SetFps(1);
    yield* Effect.sleep("5 seconds");
    const version = yield* client.Version();
    yield* Effect.logInfo(`Tiny Tower version: ${version}`);

    const banner = `/**
     * This file was auto-generated by a frida agent.
     *
     * Generated On: ${new Date().toUTCString()}
     *
     * With Tiny Tower Version: ${version}
     */
    `;

    yield* Effect.logInfo("Generating Bitbook posts data");
    const { eventTypes, mediaTypes, posts } = yield* client.GetAllBitbookPosts();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerBitbookPosts.ts"),
        `${banner}
        export const eventTypes = ${JSON.stringify(eventTypes)} as const;\n
        export type EventType = keyof typeof eventTypes;\n\n
        export const mediaTypes = ${JSON.stringify(mediaTypes)} as const;\n
        export type MediaType = keyof typeof mediaTypes;\n\n
        export const posts = ${replaceEnumTypeFields(replaceEnumTypeFields(JSON.stringify(posts), "mediatype", mediaTypes, "mediaTypes"), "event", eventTypes, "eventTypes")} as const;\n
        export type Post = (typeof posts)[number];
        `
    );

    // yield* client.GetAllBitizenData();

    yield* Effect.logInfo("Generating costumes data");
    const costumes = yield* client.GetAllCostumes();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerCostumes.ts"),
        `${banner}
        export const costumes = ${JSON.stringify(costumes)} as const;\n
        export type Costume = keyof typeof costumes;
        `
    );

    yield* Effect.logInfo("Generating elevators data");
    const elevators = yield* client.GetAllElevators();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerElevators.ts"),
        `${banner}
        export const elevators = ${JSON.stringify(elevators)} as const;\n
        export type Elevator = (typeof elevators)[number];
        `
    );

    yield* Effect.logInfo("Generating floors data");
    const { floors, types: floorTypes } = yield* client.GetAllFloors();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerFloors.ts"),
        `${banner}
        export const floorType = ${JSON.stringify(floorTypes)} as const;\n
        export type FloorType = keyof typeof floorType;\n\n
        export const floors = ${replaceEnumTypeFields(JSON.stringify(sortIndexable(floors)), "type", floorTypes, "floorType")} as const;\n
        export type Floor = (typeof floors)[number];
        `
    );

    yield* Effect.logInfo("Generating missions data");
    const { missions, tipMissions, tutorialMissions, types: missionTypes } = yield* client.GetAllMissions();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerMissions.ts"),
        `${banner}
        export const missionType = ${JSON.stringify(missionTypes)} as const;\n
        export type MissionType = keyof typeof missionType;\n\n
        export const tutorialMissions = ${replaceEnumTypeFields(JSON.stringify(tutorialMissions), "mType", missionTypes, "missionType")} as const;\n
        export type TutorialMission = (typeof tutorialMissions)[number];\n\n
        export const tipMissions = ${replaceEnumTypeFields(JSON.stringify(tipMissions), "mType", missionTypes, "missionType")} as const;\n
        export type TipMission = (typeof tipMissions)[number];\n\n
        export const missions = ${replaceEnumTypeFields(JSON.stringify(missions), "mType", missionTypes, "missionType")} as const;\n
        export type Mission = (typeof missions)[number];
        `
    );

    yield* Effect.logInfo("Generating pets data");
    const pets = yield* client.GetAllPets();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerPets.ts"),
        `${banner}
        export const pets = ${JSON.stringify(pets)} as const;\n
        export type Pet = keyof typeof pets;
        `
    );

    yield* Effect.logInfo("Generating roofs data");
    const roofs = yield* client.GetAllRoofs();
    yield* fileSystem.writeFileString(
        path.join(internalDir, "tinytowerRoofs.ts"),
        `${banner}
        export const roofs = ${JSON.stringify(roofs)} as const;\n
        export type Roof = (typeof roofs)[number];
        `
    );
});

const DeviceLive = pipe(
    FridaDevice.layerAndroidEmulatorDeviceConfig("Small_Phone", {
        fridaExecutable: "/data/local/tmp/frida-server-17.5.2-android-arm64",
        extraEmulatorArgs: ["-gpu", "swiftshader_indirect"],
    })
    // Layer.tap(
    //     Effect.fnUntraced(
    //         function* (deviceCtx: Context.Context<FridaDevice.FridaDevice>) {
    //             const device = Context.get(deviceCtx, FridaDevice.FridaDevice);
    //             const emulatorName = String.replace("android-emulator://", "")(device.host);
    //             const apks = yield* Effect.provide(
    //                 GooglePlayApi.download("com.nimblebit.tinytower"),
    //                 GooglePlayApi.defaultHttpClient
    //             );

    //             yield* Effect.annotateCurrentSpan({
    //                 "apk.path": apks,
    //                 "emulator.name": emulatorName,
    //             });

    //             const installCommand = Command.make(
    //                 "/Users/leo.conforti/Library/Android/sdk/platform-tools/adb",
    //                 "-s",
    //                 emulatorName,
    //                 "install-multiple",
    //                 "-r", // Replace existing application (if present)
    //                 "-t", // Allow test packages
    //                 "-g", // Grant all runtime permissions
    //                 "-d", // Allow downgrade
    //                 ...apks.map((apk) => apk.file)
    //             );

    //             const exitCode = yield* Command.exitCode(installCommand);
    //             if (exitCode !== 0) {
    //                 return yield* new FridaDeviceAcquisitionError.FridaDeviceAcquisitionError({
    //                     attempts: 1,
    //                     acquisitionMethod: "android-emulator",
    //                     cause: new Cause.RuntimeException(`Failed to install APK. Exit code: ${exitCode}`),
    //                 });
    //             }
    //         },
    //         Effect.scoped,
    //         Effect.timed,
    //         Effect.map(Tuple.getFirst),
    //         Effect.flatMap((time) => Effect.logDebug(`APK downloading and installing took ${time}`)),
    //         Effect.asVoid
    //     )
    // ),
    // Layer.provide(NodeContext.layer)
);

const Live = pipe(
    AgentLive,
    Layer.provideMerge(DeviceLive),
    Layer.provideMerge(Layer.merge(Logger.minimumLogLevel(LogLevel.All), NodeContext.layer))
);

program.pipe(Effect.scoped, Effect.provide(Live), NodeRuntime.runMain);
