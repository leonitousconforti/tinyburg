import { Command, FileSystem, Path } from "@effect/platform";
import { NodeContext, NodeRuntime } from "@effect/platform-node";
import { RpcClient } from "@effect/rpc";
import { FridaDevice, FridaDeviceAcquisitionError } from "@efffrida/frida-tools";
import { GooglePlayApi } from "@efffrida/gplayapi";
import { Array, Cause, Context, Effect, Layer, Logger, LogLevel, Order, pipe, Record, String, Tuple } from "effect";

import { AgentLive } from "@tinyburg/insight/node/index";
import { Rpcs } from "@tinyburg/insight/shared/Rpcs";

const sortIndexable = <T extends Readonly<{ index: string }>>(
    input: Readonly<Record<string, T>>
): Array<Omit<T, "index"> & { readonly name: string }> =>
    pipe(
        input,
        Record.toEntries,
        Array.map(([name, object]) => ({ name, ...object })),
        Array.sortWith(({ index }) => Number.parseInt(index), Order.number),
        Array.map(({ index: _index, ...rest }) => ({ ...rest }))
    );

const replaceEnumTypeFields = (
    stringified: string,
    fieldname: string,
    enums: Readonly<Record<string, string>>,
    typeName: string
): string => {
    return stringified.replace(
        new RegExp(`"${fieldname}":\\s*"(${Object.keys(enums).join("|")})"`, "g"),
        (_match, p1) => `"${fieldname}": ${typeName}.${p1}`
    );
};

const replaceGeneratedContent = (
    filePath: string,
    newContent: string
): Effect.Effect<void, Error, FileSystem.FileSystem> =>
    Effect.gen(function* () {
        const fileSystem = yield* FileSystem.FileSystem;
        const existingContent = yield* fileSystem.readFileString(filePath);
        const SEPARATOR = "//////////////////////////////////////////////////////////////////";
        const separatorPattern = new RegExp(`(${SEPARATOR})([\\s\\S]*?)(${SEPARATOR})`, "g");

        if (!separatorPattern.test(existingContent)) {
            return yield* Effect.dieMessage(`Expected two separators in file: ${filePath}`);
        }

        const updatedContent = existingContent.replace(
            new RegExp(`(${SEPARATOR})([\\s\\S]*?)(${SEPARATOR})`),
            `$1\n\n${newContent}\n\n$3`
        );

        yield* fileSystem.writeFileString(filePath, updatedContent);
    });

const generateData = Effect.gen(function* () {
    const path = yield* Path.Path;
    const srcDir = yield* path.fromFileUrl(new URL("../src", import.meta.url));

    const client = yield* RpcClient.make(Rpcs);
    yield* client.SetFps(1);
    yield* Effect.sleep("5 seconds");
    const version = yield* client.Version();
    yield* Effect.logInfo(`Tiny Tower version: ${version}`);

    const banner = `/**
     * This file was auto-generated by a frida agent.
     *
     * Generated On: ${new Date().toUTCString()}
     *
     * With Tiny Tower Version: ${version}
     */
    `;

    yield* Effect.logInfo("Generating bitbook posts data");
    const { eventTypes, mediaTypes, posts } = yield* client.GetAllBitbookPosts();
    yield* replaceGeneratedContent(
        path.join(srcDir, "BitbookPosts.ts"),
        `${banner}
        export const eventTypes = ${JSON.stringify(eventTypes)} as const;\n
        export type EventType = keyof typeof eventTypes;\n\n
        export const mediaTypes = ${JSON.stringify(mediaTypes)} as const;\n
        export type MediaType = keyof typeof mediaTypes;\n\n
        export const posts = ${replaceEnumTypeFields(replaceEnumTypeFields(JSON.stringify(posts), "mediatype", mediaTypes, "mediaTypes"), "event", eventTypes, "eventTypes")} as const;\n
        export type Post = (typeof posts)[number];
        `
    );

    yield* Effect.logInfo("Generating bitizen data");
    const {
        femaleLastNames,
        femaleNames,
        maleLastNames,
        maleNames,
        numberBiHats,
        numberFemaleHats,
        numberGlasses,
        numberHairAccessories,
        numberMaleHats,
    } = yield* client.GetAllBitizenData();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Bitizens.ts"),
        `${banner}
        export const numberBiHats = ${numberBiHats} as const;
        export const numberFemaleHats = ${numberFemaleHats} as const;
        export const numberGlasses = ${numberGlasses} as const;
        export const numberHairAccessories = ${numberHairAccessories} as const;
        export const numberMaleHats = ${numberMaleHats} as const;\n
        export const maleNames = ${JSON.stringify(femaleNames)} as const;\n
        export const maleLastNames = ${JSON.stringify(femaleLastNames)} as const;\n
        export const femaleNames = ${JSON.stringify(maleNames)} as const;\n
        export const femaleLastNames = ${JSON.stringify(maleLastNames)} as const;\n
        `
    );

    yield* Effect.logInfo("Generating costumes data");
    const costumes = yield* client.GetAllCostumes();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Costumes.ts"),
        `${banner}
        export const costumes = ${JSON.stringify(costumes)} as const;\n
        export type Costume = keyof typeof costumes;
        `
    );

    yield* Effect.logInfo("Generating elevators data");
    const elevators = yield* client.GetAllElevators();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Elevators.ts"),
        `${banner}
        export const elevators = ${JSON.stringify(elevators)} as const;\n
        export type Elevator = (typeof elevators)[number];
        `
    );

    yield* Effect.logInfo("Generating floors data");
    const { floors, types: floorTypes } = yield* client.GetAllFloors();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Floors.ts"),
        `${banner}
        export const floorType = ${JSON.stringify(floorTypes)} as const;\n
        export type FloorType = keyof typeof floorType;\n\n
        export const floors = ${replaceEnumTypeFields(JSON.stringify(sortIndexable(floors)), "type", floorTypes, "floorType")} as const;\n
        export type Floor = (typeof floors)[number];
        `
    );

    yield* Effect.logInfo("Generating missions data");
    const { missions, tipMissions, tutorialMissions, types: missionTypes } = yield* client.GetAllMissions();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Missions.ts"),
        `${banner}
        export const missionType = ${JSON.stringify(missionTypes)} as const;\n
        export type MissionType = keyof typeof missionType;\n\n
        export const tutorialMissions = ${replaceEnumTypeFields(JSON.stringify(tutorialMissions), "mType", missionTypes, "missionType")} as const;\n
        export type TutorialMission = (typeof tutorialMissions)[number];\n\n
        export const tipMissions = ${replaceEnumTypeFields(JSON.stringify(tipMissions), "mType", missionTypes, "missionType")} as const;\n
        export type TipMission = (typeof tipMissions)[number];\n\n
        export const missions = ${replaceEnumTypeFields(JSON.stringify(missions), "mType", missionTypes, "missionType")} as const;\n
        export type Mission = (typeof missions)[number];
        `
    );

    yield* Effect.logInfo("Generating pets data");
    const pets = yield* client.GetAllPets();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Pets.ts"),
        `${banner}
        export const pets = ${JSON.stringify(pets)} as const;\n
        export type Pet = keyof typeof pets;
        `
    );

    yield* Effect.logInfo("Generating roofs data");
    const roofs = yield* client.GetAllRoofs();
    yield* replaceGeneratedContent(
        path.join(srcDir, "Roofs.ts"),
        `${banner}
        export const roofs = ${JSON.stringify(roofs)} as const;\n
        export type Roof = (typeof roofs)[number];
        `
    );
});

const DeviceLive = pipe(
    FridaDevice.layerAndroidEmulatorDeviceConfig("Small_Phone", {
        fridaExecutable: "/data/local/tmp/frida-server-17.5.2-android-arm64",
        extraEmulatorArgs: ["-gpu", "swiftshader_indirect"],
    }),
    Layer.tap(
        Effect.fnUntraced(
            function* (deviceCtx: Context.Context<FridaDevice.FridaDevice>) {
                const device = Context.get(deviceCtx, FridaDevice.FridaDevice);
                const emulatorName = String.replace("android-emulator://", "")(device.host);
                const apks = yield* Effect.provide(
                    GooglePlayApi.download("com.nimblebit.tinytower"),
                    GooglePlayApi.defaultHttpClient
                );

                yield* Effect.annotateCurrentSpan({
                    "apk.path": apks,
                    "emulator.name": emulatorName,
                });

                const installCommand = Command.make(
                    "/Users/leo.conforti/Library/Android/sdk/platform-tools/adb",
                    "-s",
                    emulatorName,
                    "install-multiple",
                    "-r", // Replace existing application (if present)
                    "-t", // Allow test packages
                    "-g", // Grant all runtime permissions
                    "-d", // Allow downgrade
                    ...apks.map((apk) => apk.file)
                );

                const exitCode = yield* Command.exitCode(installCommand);
                if (exitCode !== 0) {
                    return yield* new FridaDeviceAcquisitionError.FridaDeviceAcquisitionError({
                        attempts: 1,
                        acquisitionMethod: "android-emulator",
                        cause: new Cause.RuntimeException(`Failed to install APK. Exit code: ${exitCode}`),
                    });
                }
            },
            Effect.scoped,
            Effect.timed,
            Effect.map(Tuple.getFirst),
            Effect.flatMap((time) => Effect.logDebug(`APK downloading and installing took ${time}`)),
            Effect.asVoid
        )
    ),
    Layer.provide(NodeContext.layer)
);

const Live = pipe(
    AgentLive,
    Layer.provideMerge(DeviceLive),
    Layer.provideMerge(Layer.merge(Logger.minimumLogLevel(LogLevel.All), NodeContext.layer))
);

Effect.gen(function* () {
    const path = yield* Path.Path;
    const fileSystem = yield* FileSystem.FileSystem;
    const srcDir = yield* path.fromFileUrl(new URL("../src", import.meta.url));

    const details = yield* Effect.provide(
        GooglePlayApi.details("com.nimblebit.tinytower"),
        GooglePlayApi.defaultHttpClient
    );

    const version = details.item?.details?.appDetails?.versionString;
    if (version === undefined) {
        return yield* Effect.dieMessage("Could not fetch Tiny Tower version from Google Play");
    }

    const generatedFiles = Array.make(
        path.join(srcDir, "BitbookPosts.ts"),
        path.join(srcDir, "Bitizens.ts"),
        path.join(srcDir, "Costumes.ts"),
        path.join(srcDir, "Elevators.ts"),
        path.join(srcDir, "Floors.ts"),
        path.join(srcDir, "Missions.ts"),
        path.join(srcDir, "Pets.ts"),
        path.join(srcDir, "Roofs.ts")
    );

    yield* Effect.logInfo(`Most recent Tiny Tower version on GooglePlay: ${version}`);
    yield* Effect.filterOrElse(
        Effect.filter(generatedFiles, (filePath) =>
            Effect.map(
                fileSystem.readFileString(filePath),
                (content) => !content.includes(`With Tiny Tower Version: ${version}`)
            )
        ),
        Array.isEmptyArray,
        () => generateData.pipe(Effect.scoped, Effect.provide(Live))
    );
}).pipe(Effect.provide(NodeContext.layer), NodeRuntime.runMain);
